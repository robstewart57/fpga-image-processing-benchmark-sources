package cal;
actor image1_iunzip () int (size = 16) In1 ==> int (size = 16) Out1, int (size = 16) Out2 : int (size = 32) consumed := 0 ;
 int (size = 8) bufferSize = 3 ;
 uint (size = 8) midPoint := 1 ;
 int (size = 16) circularBuffer [3] := [0, 0, 0] ;
 uint (size = 8) maxLookAhead = 1 ;
 function myMod (int (size = 16) x) --> int (size = 16) : if x > 2 * bufferSize - 1 then x - 2 * bufferSize else if x > bufferSize - 1 then x - bufferSize else x end end end firstNPixels : action In1 : [t1, t2] ==> do consumed := consumed + 2;
circularBuffer [0] := t1;
circularBuffer [1] := t2;
end streamFun1 : action In1 : [t1] ==> Out1 : [out] var int (size = 16) out do circularBuffer [myMod (midPoint + maxLookAhead)] := t1;
out := (circularBuffer [midPoint] - ((((circularBuffer [if midPoint - 1 >= 0 then midPoint - 1 else bufferSize - 1 end] + circularBuffer [myMod (midPoint + 1)])) >> 1)));
midPoint := myMod (midPoint + 1);
consumed := consumed + 1;
end streamFun2 : action In1 : [t1] ==> Out2 : [out] var int (size = 16) out do circularBuffer [myMod (midPoint + maxLookAhead)] := t1;
out := (circularBuffer [midPoint] + ((((circularBuffer [if midPoint - 1 >= 0 then midPoint - 1 else bufferSize - 1 end] + circularBuffer [myMod (midPoint + 1)])) >> 2)));
midPoint := myMod (midPoint + 1);
consumed := consumed + 1;
end streamEndFun1 : action ==> Out1 : [out], Out2 : [out] guard consumed = 262144 var int (size = 16) out do out := (circularBuffer [midPoint] - ((((circularBuffer [if midPoint - 1 >= 0 then midPoint - 1 else bufferSize - 1 end] + circularBuffer [myMod (midPoint + 1)])) >> 1)));
midPoint := myMod (midPoint + 1);
end streamEndFun2 : action ==> Out1 : [out], Out2 : [out] guard consumed = 262144 var int (size = 16) out do out := (circularBuffer [midPoint] + ((((circularBuffer [if midPoint - 1 >= 0 then midPoint - 1 else bufferSize - 1 end] + circularBuffer [myMod (midPoint + 1)])) >> 2)));
midPoint := myMod (midPoint + 1);
end schedule fsm s0 : s0 (firstNPixels) --> s1 ;
 s1 (streamFun1) --> s2 ;
 s2 (streamFun2) --> s1 ;
 s1 (streamEndFun1) --> s0 ;
 s2 (streamEndFun2) --> s0 ;
 end priority streamEndFun1 > streamFun1 ;
 streamEndFun2 > streamFun2 ;
 end end